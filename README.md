Message For You, Sir [![Build Status](https://travis-ci.org/binaryphile/concorde.svg?branch=master)](https://travis-ci.org/binaryphile/concorde)
====================

Bash scripting in my own particular...\[sigh\]...

Concorde: "Idiom, sir?"

Idiom!

Concorde is a library of functions written to work with my bash
programming style.

Features
========

-   an [enhanced-getopt style] option parser: *parseopt*

-   utility functions for [arrays] and [hashes] (a.k.a. "[associative
    arrays][hash]")

-   support for test frameworks, such as [shpec]: *sourced?*

-   stopping on errors: *[strict_mode]*

-   tracebacks on errors

-   namespacing of module function imports via [module]

-   [keyword arguments] for functions

Requirements
============

-   GNU *[readlink]* on your PATH - this is already the case on most
    Linux systems - for Mac users, *[greadlink]* from homebrew is also
    acceptable

-   GNU *sed* on your PATH - this is already the case on most Linux
    systems

-   bash 4.3 or 4.4 - tested with:

    -   4.3.11

    -   4.3.33

    -   4.3.42

    -   4.4.12

Concorde requires that you use newline as your *IFS* setting.  This
disables word-splitting on spaces.

Concorde also requires that you disable *path expansion*, or *globbing*.
It supplies a replacement function, *glob*.

These requirements mean that you should open your scripts with:

```bash
IFS=$'\n'
set -o noglob
```

Concorde doesn't enforce these settings for you, but expects you to set
them and will not work correctly if globbing is enabled or if *IFS*
contains a space or more than one character.  It's ok to temporarily set
them otherwise in your code if you aren't calling concorde functions,
but be sure to set them back.  Concorde doesn't check.

Installation
============

Clone or download this repository, then put its *lib* directory in your
PATH, or copy *lib/concorde.bash* into a PATH directory.

Use *source concorde.bash* in your scripts.

Usage
=====

Consult the API specification below for full details.

A Sample Script Template
------------------------

``` bash
#!/usr/bin/env bash

IFS=$'\n'
set -o noglob

source concorde.bash

get Usage <<END
  Usage:  script [options] <positional_arguments>...

    Options:
      -o <value>, --option=<value>    a value to pass into the script
      -p                              a flag that is true when given
END

main () {
  arg1=$1; shift
  kwargs $*

  do_something_with $option_var           # use the option value
  (( p_flag )) && do_something_with_flag  # test if -p was supplied
  
  do_something_with $arg1                 # use the positional argument
}

[other functions...]

sourced? && return      # stop here when testing the script
strict_mode on          # stop on errors and issue a traceback

# define command-line options
get Option_defs <<END
  '-o|--option',option_var
  -p,p_flag,f
EOS

! args? && die "$Usage"

parseopts "$*" "${Option_defs[*]}" Posargs Options
noerror? || die "$Usage"

main ${Posargs[*]} ${Options[*]}
```

Functions Which Return Boolean Values
-------------------------------------

Functions used for their truth value are typically used in expressions
in order to trigger actions.

For example the *sourced?* function typically is used like so:

``` bash
sourced? && return
```

These functions use the normal bash return code mechanism where *0* is
success and any other value is failure.

By convention, they are named with a question mark at the end to denote
a boolean return value.

Functions Which Return Strings
------------------------------

Bash's typical mechanism for storing strings generated by a function is
to use [command substitution].

For example, the result of an *echo* command might be stored like so:

``` bash
# this is not how concorde returns strings
my_value=$(echo "the value")
```

You can use concorde functions this way if you want, although it is not
very efficient to use a subshell.  It can be useful if you are employing
a function in a pipeline, however.

If you want to obtain a returned string in a variable (local or global),
supply the name of the variable as the last argument to the function:

``` bash
get myvalue <<END
  a multiline
  string value
END
echo "$myvalue"
```

Note that here we are taking a multiline string into the *myvalue*
variable.  Since *IFS* is newline and the value contains newlines, we
have to use double-quotes on the expansion of that variable.

This method is not usable in pipelines since each element of a pipeline
is run in a subshell.  Any variable set in the subshell is discarded by
the parent shell.  Therefore with pipelines you must use a command
substitution to capture its string output.

``` bash
# doesn't work
echo "the value" | get myvalue

# does work
myvalue=$(echo "the value" | get)
```

  [enhanced-getopt style]: https://linux.die.net/man/1/getopt
  [array]: http://wiki.bash-hackers.org/syntax/arrays
  [hash]: http://wiki.bash-hackers.org/syntax/arrays#associative_bash_4
  [shpec]: https://github.com/rylnd/shpec/tree/0.2.2
  [strict_mode]: http://www.binaryphile.com/bash/2018/08/09/approach-bash-like-a-developer-part-11-strict-mode.html
  [keyword arguments]: https://en.wikipedia.org/wiki/Named_parameter
  [readlink]: https://linux.die.net/man/1/readlink
  [greadlink]: https://apple.stackexchange.com/questions/69223/how-to-replace-mac-os-x-utilities-with-gnu-core-utilities/88812
