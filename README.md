Message For You, Sir [![Build Status](https://travis-ci.org/binaryphile/concorde.svg?branch=master)](https://travis-ci.org/binaryphile/concorde)
====================

Bash scripting in my own particular...\[sigh\]...

Concorde: "Idiom, sir?"

Idiom!

Concorde is a toolkit for writing bash scripts and libraries.

Features
========

-   an enhanced-getopt-style option parser - `parse_options`

-   array and hash utility functions (hashes as in "associative arrays")

-   smarter versions of `source`, a.k.a. the `.` operator - `require`
    and `require_relative`

-   support for test frameworks - `sourced`

-   namespaces to isolate library variables from one another

-   importation of only specified functions from libraries - `bring`

Requirements
============

-   GNU `readlink` on your PATH - for Mac users, `greadlink` is also
    acceptable

-   `sed` on your PATH

-   bash 4.3 or 4.4 - tested with:

    -   4.3.11

    -   4.3.33

    -   4.3.42

    -   4.4.12

Reserved Global Variables
=========================

Concorde reserves a couple global variables for its own use.  They begin
with `__` (double-underscore)

-   `__` - double-underscore itself

-   `__ns` - short for "namespace"

Any script or library used with concorde cannot change the purpose of
these variables.

Installation
============

Clone or download this repository, then put its `lib` directory in your
PATH, or copy `lib/concorde.bash` into a PATH directory.

Use `source concorde.bash` in your scripts.

Usage
=====

Consult the API specification below for full details.

Functions Which Return Boolean Values
-------------------------------------

Functions used for their truth value are typically used in expressions
in order to trigger actions.

For example the `sourced` function typically is used like so:

```bash
sourced && return
```

These functions use the normal bash return code mechanism where `0` is
success and any other value is failure.

Functions Which Return Strings
------------------------------

Bash's typical mechanism for storing strings generated by a function is
to use command substitution.

For example, the result of an `echo` command might be stored like so:

```bash
# This is not concorde's method of doing this
my_value=$(echo "the value")
```

Concorde doesn't use this method as it is prone to capturing unexpected
output and also requires an unnecessary subshell.

Any concorde function which returns a string value does so in the global
variable `__` (double-underscore).

Because any function is allowed to overwrite `__` to return a value, you
want to save that value before calling any other functions like so:

```bash
get <<<"the value"
my_value=$__
```

`get` is a concorde function which stores a string from `stdin` and
`<<<` feeds it the supplied string.

`__` must be treated much the same as the `$?` return code, since every
successive command may change it.

Note that because `__` is a global, it is discarded by the subshells
which are employed by pipelines.  Therefore you cannot use pipelines to
return strings from concorde functions.  For example, this will not
work:

```bash
# Doesn't work
echo "the value" | get
my_value=$__
```

Because `__`'s value is ephemeral, it can be used to hold interim values
and feed the output of one operation to the next:

```bash
get <<<"the value"
to_upper "$__"
value=$__
```

`to_upper` capitalizes the input string and returns it in `__`.

Note that `__` is always a string value.  Your functions which use it to
return a string should be careful not to store an actual array or hash
in it (e.g. `__=( "array item" )`).

This is because some of concorde's features rely on `__`'s type to be
string.  Since bash automatically converts a string variable to an array
or hash when assigned, doing so can interfere with concorde.  Once
assigned, an array or hash variable cannot automatically be converted
back to a string and concorde cannot safeguard `__`'s type.

Dealing with Hashes and Arrays as Parameters
--------------------------------------------

Bash can pass string variables to functions, but is not able to pass
arrays nor hashes as individual parameters to a function.

If an array needs to be treated as a singular parameter to a function,
typical bash practice is to use the shortcut of not passing it at all
and instead just referring to the global variable directly by name.

Another approach is to use named references (`declare -n` or
`${!reference}`) instead of using a normal local variable.

For a variety of reasons, each of these approaches is problematic.

The workaround employed by concorde is to convert arrays and hashes to
strings (serialize them) when crossing function boundaries, whether as
arguments or return values. Bash is good at passing strings, and ok at
returning them too. At least, it's better at it than at returning
arrays.

Any concorde function which expects an array or hash argument will
expect a string representation of the array.

Although bash doesn't have a general-purpose string literal
representation for an array, it does define such a format in its array
assignment statements. You can see an example by running `declare -p
<variable_name>`.

I borrow the same format, with minor changes, for the array literals
expected by concorde's functions.

For example, to call a function `my_func` which expects a single array
argument, you might define the array, then use concorde's `repr`
function to generate the string format:

```bash
my_ary=( "first item" "second item" )
repr my_ary
my_func "$__"
```

Notice that `repr` takes the name of the array as an argument and
returns the string representation in `__`.

To write a function which receives such an argument, you use concorde's
`local_ary` function:

```bash
my_func () {
  $(local_ary input_ary=$1)
  local item

  for item in "${input_ary[@]}"; do
    echo "$item"
  done
}
```

`ary` is short for "array".

`local_ary` creates a local array variable, in this case `input_ary`,
and gives it the contents provided in the string argument.  For the rest
of the function you use it like a normal array, because it is one.

Note that the `$()` command substitution operator around `local_ary` is
necessary.  Without it, `local_ary` can't create a local variable in the
scope of the caller.
