Message For You, Sir [![Build Status](https://travis-ci.org/binaryphile/concorde.svg?branch=master)](https://travis-ci.org/binaryphile/concorde)
====================

Bash scripting in my own particular...\[sigh\]...

Concorde: "Idiom, sir?"

Idiom!

Concorde is a toolkit for writing bash scripts and libraries.

Features
========

-   a getopt-style option parser - `parse_options`

-   array and hash (a.k.a. associative array) functions

-   smarter versions of `source` (a.k.a. `.`) - `require` and
    `require_relative`

-   isolated global variable namespaces for different libraries

-   support for test frameworks - `sourced`

-   importation of only specified functions from libraries - `bring`

Requirements
============

-   GNU `readlink` on your PATH - for Mac users, `greadlink` is also
    acceptable

-   `sed` on your PATH

-   bash version 4.3 or 4.4 - tested with:

    - 4.x

    - etc

Reserved Global Variables
=========================

Concorde reserves a couple global variables for its own use.  They begin
with `__` (double-underscore)

-   `__` - double-underscore itself

-   `__ns` - short for "namespace"

Any script or library used with concorde cannot change the purpose of
these variables.

Installation
============

Clone or download this repository, then put its `lib` directory in your
PATH, or copy `lib/concorde.bash` into a PATH directory.

Use `source concorde.bash` in your scripts.

Usage
=====

Consult the API specification below for full details.

Functions Which Return Boolean Values
-------------------------------------

Functions used for their truth value are typically used in expressions
in order to trigger actions.

For example the `sourced` function typically is used like so:

```
sourced && return
```

These functions use the normal bash return code mechanism where `0` is
success and any other value is failure.

Functions Which Return Strings
------------------------------

Bash's typical mechanism for storing strings generated by a function is
to use command substitution.

For example, the result of an `echo` command might be stored like so:

```
# This is not concorde's method of doing this
my_value=$(echo "the value")
```

Concorde doesn't use this method, as it is prone to capturing unexpected
output (among other reasons).

Any concorde function which returns a string value does so in the global
variable `__` (double-underscore).

Because any function is allowed to overwrite `__` to return a value, you
want to save that value before calling any other functions like so
(`get` is a concorde function and `<<<` introduces a here-string):

```
get <<<"the value"
my_value=$__
```

This is much like how you must treat the value of the `$?` return code
variable, since every command changes it.

Note that because `__` is a global, it is discarded by the subshells
which are employed by pipelines.  Therefore you cannot use pipelines to
return strings from concorde functions.  For example, this will not
work:

```
# Doesn't work
echo "the value" | get
my_value=$__
```

Dealing with Hashes and Arrays as Parameters
--------------------------------------------

Bash can pass string variables to functions, but is not able to pass
arrays (or hashes) as individual parameters to a function.

If expanding an array into the positional arguments of a function call
isn't acceptable, then typical bash practice is to refer to the array
directly in an outer scope (e.g. a global variable) or to use named
references (`declare -n` or `${!reference}`).

For many reasons, each of these approaches is problematic.

The workaround employed by concorde is to simply convert arrays and
hashes to strings (serialize them) when crossing function boundaries,
either as arguments or return values.  Bash is good at passing strings.
It's ok at returning them too, or at least better at it than at
returning arrays.

Any concorde function which expects an array or hash argument will
expect a string representation of the array.

Although bash doesn't formally have a string literal representation for
an array, it does define such a format in its array assignment
statements (you can see an example by running `declare -p
<variable_name>`).

I borrow the same format, with minor changes, for the array literals
expected by concorde's functions.

For example, to call a function `my_func` which expects a single array
argument, you might define the array, then use concorde's `repr`
function to generate the string format:

```
my_ary=( "first item" "second item" )
repr my_ary
my_func "$__"
```

Notice that `repr` takes the name of the array as an argument and
returns the string representation in `__`.

To write a function which receives such an argument, you use concorde's
`local_ary` function:

```
my_func () {
  $(local_ary input_ary=$1)
  local item

  for item in "${input_ary[@]}"; do
    echo "$item"
  done
}
```

`local_ary` creates a local array variable, in this case `input_ary`,
and gives it the contents provided in the string argument.  For the rest
of the function you use it like a normal array, because it is one.

Note that the `$()` command substitution operator around `local_ary` is
necessary for it to be able to create the `input_ary` variable in the
calling function's (that's `my_func`'s) local scope.
