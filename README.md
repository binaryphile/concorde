Message For You, Sir [![Build Status](https://travis-ci.org/binaryphile/concorde.svg?branch=master)](https://travis-ci.org/binaryphile/concorde)
====================

Bash scripting in my own particular...\[sigh\]...

Concorde: "Idiom, sir?"

Idiom!

Concorde is a toolkit for writing bash scripts and libraries.

Features
========

-   an enhanced-getopt-style option parser - `parse_options`

-   array and hash utility functions (hashes as in "associative arrays")

-   smarter versions of `source`, a.k.a. the `.` operator - `require`
    and `require_relative`

-   support for test frameworks - `sourced`

-   namespaces to isolate library variables from one another

-   importation of only specified functions from libraries - `bring`

Requirements
============

-   GNU `readlink` on your PATH - for Mac users, `greadlink` is also
    acceptable

-   `sed` on your PATH

-   bash 4.3 or 4.4 - tested with:

    -   4.3.11

    -   4.3.33

    -   4.3.42

    -   4.4.12

Reserved Global Variables
=========================

Concorde reserves a couple global variables for its own use.  They begin
with `__` (double-underscore)

-   `__` - double-underscore itself

-   `__ns` - short for "namespace"

Any script or library used with concorde cannot change the purpose of
these variables.

Installation
============

Clone or download this repository, then put its `lib` directory in your
PATH, or copy `lib/concorde.bash` into a PATH directory.

Use `source concorde.bash` in your scripts.

Usage
=====

Consult the API specification below for full details.

Functions Which Return Boolean Values
-------------------------------------

Functions used for their truth value are typically used in expressions
in order to trigger actions.

For example the `sourced` function typically is used like so:

```bash
sourced && return
```

These functions use the normal bash return code mechanism where `0` is
success and any other value is failure.

Functions Which Return Strings
------------------------------

Bash's typical mechanism for storing strings generated by a function is
to use command substitution.

For example, the result of an `echo` command might be stored like so:

```bash
# This is not concorde's method of doing this
my_value=$(echo "the value")
```

Concorde doesn't use this method as it is prone to capturing unexpected
output and also requires an unnecessary subshell.

Any concorde function which returns a string value does so in the global
variable `__` (double-underscore).

Because any function is allowed to overwrite `__` to return a value, you
want to save that value before calling any other functions like so:

```bash
get <<<"the value"
my_value=$__
```

`get` is a concorde function which stores a string from `stdin` and
`<<<` feeds it the supplied string.

`__` must be treated much the same as the `$?` return code, since every
successive command may change it.

Note that because `__` is a global, it is discarded by the subshells
which are employed by pipelines.  Therefore you cannot use pipelines to
return strings from concorde functions.  For example, this will not
work:

```bash
# Doesn't work
echo "the value" | get
my_value=$__
```

Because `__`'s value is ephemeral, it can be used to hold interim values
and feed the output of one operation to the next:

```bash
get <<<"the value"
to_upper "$__"
value=$__
```

`to_upper` capitalizes the input string and returns it in `__`.

Note that `__` is always a string value.  Your functions should be
careful not to store an actual array or hash in it (e.g. `__=( "array
item" )`).

This is because some of concorde's features rely on `__`'s type to be
string.  Since bash automatically converts a string variable to an array
or hash when assigned, doing so can interfere with concorde.  Once
assigned.

Dealing with Hashes and Arrays as Parameters
--------------------------------------------

Bash can pass string variables to functions, but is not able to pass
arrays nor hashes as individual parameters to a function.

If an array needs to be treated as a singular parameter to a function,
typical bash practice is to use the shortcut of not passing it at all
and instead just referring to the global variable directly by name.

Another approach is to use named references (`declare -n` or
`${!reference}`) instead of using a normal local variable.

For a variety of reasons, each of these approaches is problematic.

The workaround employed by concorde is to convert arrays and hashes to
strings (serialize them) when crossing function boundaries, whether as
arguments or return values.  This gives you full control of your
variable namespace. And while it's not good at passing arrays (hashes
especially), bash is good at passing strings, so why not use that.

Any concorde function which expects an array or hash argument will
expect a string representation of the array. Although there are a couple
functions which actually operate on arrays/hashes directly, those are
clearly noted in the API documentation.

Although bash doesn't have a general-purpose string literal
representation for an array, it does define such a format in its array
assignment statements. You can see an example by running `declare -p
<variable_name>`.

Concorde borrows the same format, with minor changes, for the array
literals expected by concorde's functions.

### Passing an Array or Hash

For example, to call a function `my_func` which expects a single array
argument, you might define the array, then use concorde's `repr`
function to generate the string format:

```bash
my_ary=( "first item" "second item" )
repr my_ary
my_func "$__"
```

Note that `repr` takes the name of the array as an argument and returns
the string representation in `__`.

The same method works for a hash.

### Receiving an Array

To write a function which receives such an argument, you use concorde's
`local_ary` function:

```bash
my_func () {
  $(local_ary input_ary=$1)
  local item

  for item in "${input_ary[@]}"; do
    echo "$item"
  done
}
```

`ary` is short for "array".

`local_ary` creates a local array variable, in this case `input_ary`,
and gives it the contents provided in the string argument.  For the rest
of the function you use it like a normal array, because it is one.

Note that the `$()` command substitution operator around `local_ary` is
necessary.  Without it, `local_ary` can't create a local variable in the
scope of the caller.

To receive a hash instead of an array, simply use the `local_hsh`
function instead of `local_ary`.

### Just Passing Through

Of course, if your function only needs to receive an array/hash in order
to pass it to another function, you don't need to convert the string
representation into its array form, you can simply receive and pass the
array in its string form:

```bash
my_function () {
  local array_representation=$1
  function2 "$array_representation"
}
```

### Passing Arrays/Hashes by Name

Both `local_ary` and `local_hsh` will allow you to pass them the name of
the variable holding the string representation instead of the
representation itself, if you so desire. They will detect the variable
name and expand it themselves.

This means you can call any concorde function which takes an array like
so:

```bash
array=( "item one" )
repr array
member_of __ "item one" && echo "'item one' is in array"
```

`member_of` takes an array and an item and returns whether the array
contains the item.  Since `repr` returns the string representation of
the array in `__`, you can feed the name `__` to `member_of` instead of
the expansion `$__`.  Of course, the expansion will work as well.

Concorde supports passing by name for array and hash representations,
but not normal strings.

### A Caveat

The one caveat introduced by the pass-by-name functionality is that when
*not* passing by name, an array representation containing a single item
which happens to be a variable name will be expanded instead of used
literally.

This is not a problem for hashes.

Be careful to avoid this situation or you will get unexpected behavior.
One workaround is to always pass by name.  Another is to add an empty
item to the array or a non-identifier character to the item, such as a
space.

A future version of concorde will limit the impact of this issue.
