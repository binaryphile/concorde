idiomatic bash
==============

Ways of taming my bash scripts.

Idiomatic bash is a small-ish library for handling a few core features
that virtually any bash script needs, along with some tools for making
bash library-friendly.  As sweet Concorde would say, these are functions
written in my own particular...[sigh]..."Idiom, sir?".  Idiom!

Libraries need to be written idiomatically (i.e. my way) in order to
work in this system, but idiomatic bash solves most of the issues which
normally prevent arbitrary bash libraries from working well with each
other (which is perhaps why there aren't a lot of canonical bash
libraries?)

Features
========

-   an option parser

-   namespace manipulation using hashes and arrays

-   module packaging functions

-   utilitarian string and array manipulations

-   ruby-style tracebacks

-   strict mode

Installation
============

Clone this repo (or copy idiomatic.bash) and make it avaiable in your
$PATH.  Then use "source idiomatic.bash" in your scripts.

Reserved Variables
==================

Idiomatic bash reserves the following global variables for its own use:

-   `__` (double-underscore)
-   `__dependencies`
-   `__idiom`
-   `__instanceh`

API
===

Internal-use functions, of which there are but a couple, start with an
underscore.  The rest form the public API.

Names which appear a little esoteric are likely that way to avoid
conflicts with similarly-named programs that you might find on a system.
For example, `wed` instead of the more standard `join` for arrays.

Some functions incorporate data types in their names when they deal with
such types, such as:

-   arrays: `ary`
-   strings: `str`
-   hashes (associative arrays): `hsh`

Functions which return string values do so in the global variable `__`
(double-underscore).

"References" may appear, usually as a return value from a `_new`
function.  A reference is simply a string variable which happens to hold
either the name of another string variable or the name and index of an
item in an array or hash (e.g.  `my_hash[key]`).

All parameters designated as "_array" or "_hash" in function signatures
actually require the literal representation of the array or hash as a
string, e.g. "(three item list)" or "([key]=value [pairs]="")", since
bash can't pass actual arrays or hashes.  If you already have such a
literal stored in a variable, the API usually allows you to pass the
un-expanded variable name (no dollar sign) instead and the value will be
automatically extrapolated.

The usual way to obtain such a literal from an active array or hash is
via `inspect`:

```
inspect my_array
function_requiring_an_array_literal "$__"
```

Usually the above function would take `__` as a valid alternative for
`$__`.

Option Parsing
--------------

-   **`options_new`** *`definitions_array`* - creates a new instance of
    an options data structure

    Options definitions are in the form of an array literal, with each
    item containing a sub-array (literal) of four elements:

        -   *short option* (including hyphen) - may be ommitted (with ''
            in its place) if *long option* is defined

        -   *long option* (including double-hyphen) - may be ommitted
            (with '' in its place) if *short option* is defined

        -   *argument name* - if the option takes an argument, the name
            of the variable in which to store the value

            -   if ommitted with '' in its place, the option becomes a
                flag with the name `flag_[option]`, where [option] is
                the long name, if available, otherwise the short name.
                It receives either the value 1 if the flag is supplied,
                or does not exist if it wasn't

        -   *help string* - currently unused but can still be a useful
            reminder

    *definitions_array* is usually supplied via `get_here_str`.  Example:

        get_here_str <<'EOS'
          ( -o --option1            ''      'a flag'  )
          ( -p --option2 argument_name 'an argument'  )
        EOS

        options_new __

*Returns*: a reference to the option data structure

-   **`options_parse`** *`options_ref [options]`* - parses a list of
    options provided as-is from the command-line (i.e. "$@")

    Requires an options data structure reference as the first argument,
    as generated by `options_new`
